# Entity-relationship Model

Формализация ER-моделей в Lean. Первое приближение.

+ [ER](ER.lean) — Модель 
+ [ER_test](ER_test.lean) — Пример использования
+ [ER_DSL](ER_DSL.lean) — DSL для ER-моделей
+ [ER_DSL_test](ER_DSL_test.lean) — пример использования
+ [ER2_test](ER2_test.lean) — Прямая формализация предметной области в
  Lean, без ориентации на RA- или ER-модели (см. комментарий ниже)

## Реляционные алгебры

+ [RA](RA.lean) — Определения для реляционных алгебр
+ [RA_DSL](RA_DSL.lean) — DSL для реляционных алгебр (пока только
  определение таблиц)
+ [RA_DSL_test](RA_DSL_test.lean) — пример использования 
+ [RA_DSL_test2](RA_DSL_test2.lean) — ещё пример использования 

## Преобразование ER-моделей в RA-модели

+ [ERtoRA](ERtoRA.lean) — Преобразование моделей. Делается чисто
  синтаксическим путём.
+ [ERtoRA_test](ERtoRA_test.lean) — пример: модель из `ER_test` преобразуется
  в модель из `RA_test`.

## Комментарии
+ Файлы `Tables` и `RA` содержат, фактически, математическую теорию
  реляционных алгебр, сформулированную в Lean
  (ср. https://lean-lang.org/functional_programming_in_lean/dependent-types/typed-queries.html,
  а также формализацию в языке Agda: https://github.com/sabauma/agda-relation-algebra).
  В них определены отношения как таблицы с заголовками и операции с ними
  (select, union,...).  В `RA_DSL` определён язык (DSL) для определения
  реляционных алгебр.  Это набор макросов, которые разворачиваются в код
  Lean в соответствии с определениями из `Tables` и `RA`.  Модель
  определяется между командами `RAModel` и `endRAModel` и состоит из
  определения типов используемых данных (`DBTypes`) и таблиц, содержащих
  эти данные.  `DBTypes` задаётся как набор идентификаторов (`name`,
  `id`,...), которым соответствуют типы Lean.  Последние могут быть любыми,
  допустимыми в Lean.  Например, `str` определён как тип непустых строк, а
  `work_place` — как тип списков строк с длиной больше 0 и меньше 4.
  Идентификаторы вида `...DBT` используются для ссылок на таблицы
  (определённые ниже).  Блок `Tables` содержит схему таблицы и затем
  описание одной или нескольких таблиц.  Файл `RA_DSL_test` содержит пример
  применения этой теории с конкретными таблицами и примером применения
  операции select.
+ Аналогично, файл `ER` содержит теорию ER-моделей.  В ней сущности
  представлены структурами (то есть, математически: кортежами), а отношения
  (пока только бинарные) — предикатами вида `A → B → Prop`.  Сущности
  обозначаются идентификаторами, и различные функции вида `NNN.bind` задают
  связь идентификаторов и построенных из них объектов с соответствующими
  значениями Lean.  Отношения `REL_11`, `REL_1N`,... это отношения с
  наложенными на них условиями кардинальности 1:1, 1:N,...  Структура `Rel
  R` представляет отношение `R` как кортеж (таблицу).  Её элементы состоят
  из двух объектов и доказательства того, что между ними имеется отношение
  `R`.  (В принципе, можно было бы сразу задавать отношения как таблицы, но
  с ними немного сложнее обращаться.)
+ Файл `ER_test` содержит пример применения теории из `ER`.  В нём
  определены 4 таблицы и некоторые отношения между ними.  Тактики
  `proveIs11`, `proveIs1N` используются для автоматического доказательства
  того, что выполнены условия кардинальности для отношений.
+ `ER_DSL` содержит DSL для задания ER-моделей.  Модель описывается между
  командами `ERModel` и `endERModel`.  Она начинается с блока атрибутов,
  аналогичного блоку `DBTypes` в RA-моделях.  Затем задаются сущности как
  наборы атрибутов и отношения между ними.  `ER_DSL_test` содержит пример
  ER-модели с таблицами и отношениями, аналогичными определённым в
  `ER_test`.  Сам файл `ER_DSL` содержит набор макросов, переводящих
  заданную модель в код Lean в соответствии с определениями из `ER` — то
  есть макросы написаны так, чтобы они разворачивались в определения из
  `ER`.  Таким образом, файл `ER_DSL_test` должен разворачиваться в код,
  представленный в `ER_test`.
+ `ERtoRA` содержит алгоритм преобразования ER-моделей в RA-модели.  Он
  содержит макросы, которые преобразуют выражения для ER-моделей `ERModel
  ... endERModel` в выражения для RA-моделей `RAModel ... endRAModel`.
  Таким образом, преобразования происходит исключительно на уровне языка:
  один DSL преобразуется в другой DSL.  Поскольку последний также
  представляет собой макрос, он далее разворачивается в код Lean.  Таким
  образом, мы имеем два файла `ER_test` и `ER_DSL_test`, в которых _одна и
  та же_ ER-модель преобразуется в два разных кода Lean: один раз в
  соответствии с `ERtoRA`, другой — в соответствии с `ER_DSL`.  При этом в
  первом случае конечный код построен из определений файла `RA`, а во
  втором — из определений файла `ER`.  Это означает, что теорию,
  сформулированную в `RA` можно считать «ядерной» — в неё преобразуются как
  RA-модели (макросами `RA_DSL`), так и ER-модели (макросами `ERtoRA`).
  (Мне лично она в качестве ядерной не очень нравится, поскольку она сильно
  специализирована, но пока так получается.)
+ Формализации ER-моделей, приведённые выше, имеют в виду их дальнейший
  перевод в RA-модель (фактически, по мотивам статьи: Chen P.P.-S. The
  Entity-Relationship Model - Toward a Unified View of Data (1976)).  Файл
  `ER2_test` содержит «прямую» формализацию предметной области в Lean, без
  ориентации на ER- или RA-модели.  В ней сущности и отношения
  формализуются не как объекты с атрибутами, а как зависимые типы.
